<!DOCTYPE html>
<html>

<head>
    <title>Text Transforms</title>
    <link rel="stylesheet" href="css/textdemo.css" />
    <link rel="stylesheet" href="css/prism.css" />
    <script src="js/scrollx.js" type="text/javascript"></script>
    <script src="js/json_module.js" type="text/javascript"></script>
    <script src="js/xsl_module.js" type="text/javascript"></script>
    <script src="js/svg_module.js" type="text/javascript"></script>
    <script src="js/dependencies/d3.v3.min.js" type="text/javascript"></script>
    <script src="js/dependencies/graphlib-dot.min.js" type="text/javascript"></script>
    <script src="js/dependencies/dagre.min.js" type="text/javascript"></script>
    <script src="js/dependencies/dagre-d3.min.js" type="text/javascript"></script>
    <script src="js/dependencies/prism.js" type="text/javascript"></script>
    <script type="text/javascript">

        // Module/name space TextTransformers
        var TextTransformers = TextTransformers || {
          JsonToHtmlTransformer: function() {
            this.transform = function( json ) {
              var html = '';
              json.sequences[0].canvases[0].resources.forEach( function( item ) {
                if( item.resource['@type'] == 'cnt:ContentAsText' ) {
                  html += '<p>' + item.resource['cnt:chars'] + '</p>'
                }
              } );
              return html;
            }
          },
          JsonToTeiTransformer: function() {
            this.transform = function( json_string ) {
              var json = JSON.parse( json_string );
              var label = json['label'];
              var manifestId = json['@id'];
              var columns = [];
              var last_x = 0;
              json.sequences[0].canvases[0].resources.forEach( function( item ) {
                if( item.resource['@type'] == 'cnt:ContentAsText' ) {
                  // Parse the coordinates
                  coords = item.on.match( /^.*#xywh=(\d+),(\d+),(\d+),(\d+)/ )
                  // See if we have started a new column
                  if( last_x < coords[1] ) {
                    columns.push( [] );
                    last_x = coords[1];
                  };
                  // Extract the information we need from this item
                  var lineid = item['@id'].match( /^.*line\/(\d+)$/ )[1];
                  columns[ columns.length - 1 ].push(
                  { 'id': lineid,
                  	'text': item.resource['cnt:chars'],
                  	'coordinates': coords
                  });
                }
              });
              var xmltext = '';
              var xmlfacs = '';
              // For each column...
              columns.forEach( function( column, cn ) {
              	// add a column break
                xmltext += '<cb n="' + ( cn + 1 ) + '"/>\n';
                // then for each line in the column...
                column.forEach( function( line, ln ) {
                  // add the text line
                  id = line['id'];
                  text = line['text'];
                  xmltext += `<lb facs="#l${id}" n="${ln+1}"/>${text}`;
                  // and the facsimile zone line.
                  ulx = line['coordinates'][1];
                  uly = line['coordinates'][2];
                  lrx = parseInt(line['coordinates'][1]) + parseInt(line['coordinates'][3]);
                  lry = parseInt(line['coordinates'][2]) + parseInt(line['coordinates'][4]);
                  xmlfacs += `<zone xml:id="l${id}" ulx="${ulx}" uly="${uly}" lrx = "${lrx}" lry="${lry}"/>`;
                });
              });
              // XML boilerplate
              var stylesheet_decl = '<?xml-stylesheet type="text/xsl" href="resources/tei_demo_doc.xsl"?>';
              // TEI header with SC label and manifest ID
              var frontmatter = '<TEI version="5.0" xmlns="http://www.tei-c.org/ns/1.0"><teiHeader><fileDesc><titleStmt><title>' + label + '</title></titleStmt><publicationStmt><p>This is a publication statement</p></publicationStmt><sourceDesc><p>' + manifestId + '</p></sourceDesc></fileDesc></teiHeader>';
              // Facsimile element with canvas info
              var surfacefile = json.sequences[0].canvases[0].label
              var surfaceheight = json.sequences[0].canvases[0].height
              var surfacewidth = json.sequences[0].canvases[0].width
              var facsimile = `<facsimile><surface ulx="0" uly="0" lrx="${surfacewidth}" lry="${surfaceheight}"><graphic url="${surfacefile}"/>${xmlfacs}</surface></facsimile>`;
              var textel = '<text><body><ab>' + xmltext + '</ab></body></text>';
              var backmatter = '</TEI>';
              var xmlDoc = stylesheet_decl + '\n' + frontmatter + '\n' + facsimile + '\n' + textel + '\n' + backmatter;
              return xmlDoc;
            }
          },
          TeiToHTMLTransformer: function() {
            this.transform = function( tei, callback ) {
              var xsl = new XSL_MODULE();
              xsl.getXSL( function( stylesheet ) {
                var xsltProcessor = new XSLTProcessor();
                xsltProcessor.importStylesheet( stylesheet );
                var parser = new DOMParser();
                var xml_doc = parser.parseFromString( tei, "text/xml" );
                var result_document = xsltProcessor.transformToFragment( xml_doc, document );
                var serializer = new XMLSerializer();
                var result_document_as_string = serializer.serializeToString( result_document );
                callback( result_document_as_string );
              } );
            }
          },
          HtmlToXmlTransformer: function() {
            this.transform = function( html ) {
              var xml = html.replace( /\<p[^\>]*\>/, '<par>' );
              xml = xml.replace( /\<\/p\>/, '</par>' );
              xml = xml.replace( /\<b\>/, '</emph>' );
              xml = xml.replace( /\<\/b\>/, '</emph>' );
              return xml;
            }
          },
          TeiToDotTransformer: function () {
          	this.transform = function( xml_string ) {
          	  // Parse the TEI string and set up XPath parsing
          	  var nsres = function( pf ) {
          	    if( pf === 't' ) {
          	      return "http://www.tei-c.org/ns/1.0";
          	    } else if ( pf === 'xml' ) {
          	      return "http://www.w3.org/XML/1998/namespace";
          	    } else {
          	      return "";
          	    }
          	  };
          	  parser = new DOMParser();
          	  teiDoc = parser.parseFromString( xml_string, "text/xml" );
          	  var byXpath = function(path, context) {
          	    context = context || teiDoc;
          	  	return teiDoc.evaluate(path, context, nsres,
          	  		XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
          	  };
          	  var setByXpath = function(path) {
          	  	return teiDoc.evaluate(path, teiDoc, nsres,
          	  		XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
          	  };

          	  // We will make simple objects for each node and edge
          	  nodes = [];
          	  edges = [];
          	  // Main text node with label and manifest
          	  nodes.push({
          	    "id": "TEXT",
          	    "class": "TEXT",
          	    "label": byXpath('//t:titleStmt/t:title').textContent,
          	    "manifestID": byXpath('//t:sourceDesc/t:p').textContent
          	  });
          	  // Make the facsimile and zone nodes with coordinates and ID
          	  nodes.push({
          	    "id": "facs",
          	    "class": "FACSIMILE",
          	    "label": byXpath('//t:graphic/@url').textContent,
          	    "h": byXpath('//t:surface/@lry').textContent,
          	    "w": byXpath('//t:surface/@lrx').textContent
          	  });
          	  edges.push(["TEXT", "facs", "HAS_FACSIMILE"]);
          	  var zones = setByXpath('//t:zone');
          	  var nextZone = zones.iterateNext();
          	  while( nextZone ) {
          	    zx = parseInt(nextZone.attributes["ulx"].nodeValue);
          	    zy = parseInt(nextZone.attributes["uly"].nodeValue);
          	    zwid = parseInt(nextZone.attributes["lrx"].nodeValue) - zx;
          	    zhgt = parseInt(nextZone.attributes["lry"].nodeValue) - zy;
          	  	zoneNode = {
          	  	  "id": nextZone.attributes["xml:id"].nodeValue,
          	  	  "class": "ZONE",
          	  	  "x": zx,
          	  	  "y": zy,
          	  	  "w": zwid,
          	  	  "h": zhgt
          	  	};
          	  	nodes.push( zoneNode );
          	  	edges.push(["facs", zoneNode['id'], 'HAS_ZONE']);
          	  	nextZone = zones.iterateNext();
          	  }

          	  // Set up our recursive function for stepping through the
          	  // child elements of a node
			  var currLine;
			  var lastToken;
			  var tidx = 0;
			  var aidx = 0;
          	  var newLine = false;
          	  var stepThroughText = function( element ) {
          	  	  var createdTokens = []
				  element.childNodes.forEach( function( nextEl ) {
					// If it's a lb, note ref for hooking up the correct zone
					if( nextEl.nodeName === "lb" ) {
					  // Close out the old line TODO
					  if( lastToken && currLine ) {
						edges.push([currLine, lastToken.id, 'UNTIL']);
					  }
					  // Note the new line
					  currLine = nextEl.attributes['facs'].nodeValue.substr(1);
					  newLine = true;

					// If it's text, split it on space
					} else if( nextEl.nodeType === nextEl.TEXT_NODE ) {
						var tokens = nextEl.nodeValue.split(/\s+/);
						var partialWord = true;
						if( tokens[0] === "" ) {
							// Remove the joinNext from the last token
							if( lastToken ) {
								delete lastToken['joinNext'];
							}
							tokens.shift();
						}
						if( tokens[tokens.length-1] === "" ) {
							// See if the last token needs a joinNext
							partialWord = false;
							tokens.pop();
						}
						// Make the token nodes
						tokens.forEach( function( token ) {
							var tnode = {
								"id": `t${tidx}`,
								"class": 'TOKEN',
								"label": token
							};
							tidx += 1;
							nodes.push( tnode );
							createdTokens.push( tnode );
							if( lastToken ) {
							  edges.push([lastToken.id, tnode.id, 'SEQUENCE']);
							}
							if( newLine ) {
							  edges.push([currLine, tnode.id, 'TRANSCRIPTION']);
							  newLine = false;
							}
							lastToken = tnode;
						});
						if( partialWord ) {
							lastToken['joinNext'] = 'true';
						}

					// If it's a cb, skip it
					// If it's any element other than cb (which we skip),
					// get its contents and make an annotation. Need to
					// recurse on the text splitting for this.
					} else if ( nextEl.nodeName != "cb" ) {
						// Make an annotation node
						var annoNode = {
							'id': `a${aidx}`,
							'class': 'ANNOTATION',
							'label': nextEl.nodeName
						};
						for( var i = 0; i < nextEl.attributes.length; i++ ) {
							var attr = nextEl.attributes[i];
							annoNode[attr.nodeName] = attr.nodeValue;
						}
						aidx += 1;
						var annoRange = stepThroughText( nextEl );
						nodes.push( annoNode );
						edges.push([annoNode.id, annoRange[0].id, 'MARKUP']);
						edges.push([annoNode.id,
									annoRange[annoRange.length-1].id, 'UNTIL']);
					}
			  	  });
			  	return createdTokens;
			  };
          	  // Go through the child elements of the ab in order
			  stepThroughText( byXpath( '//t:ab' ) );
			  // Hook up the last line ending to the last token
			  edges.push([currLine, lastToken.id, 'UNTIL']);

          	  // Now output a dot string with the nodes and the edges
          	  var dotString = 'digraph theText {\n'
          	  nodes.forEach( function( node, idx ) {
          	  	var nodeString = '  ' + node.id + ' [ ';
          	  	Object.keys(node).forEach( function( key ) {
          	  		if( key != 'id' ) {
          	  			nodeString += `${key}="${node[key]}" `;
          	  		}
          	  	});
          	  	nodeString += ']';
          	  	dotString += nodeString + '\n';
          	  });
          	  edges.forEach( function( edge ) {
          	  	var edgeString = `  ${edge[0]} -> ${edge[1]} [ name="${edge[2]}" ]`
          	  	dotString += edgeString + '\n';
          	  });
          	  dotString += '}';
          	  return dotString;
          	}
          },
          set_textarea_content: function( textarea_id, content ) {
            var textarea = gEBI( textarea_id );
            textarea.value = content;
          },
          set_iframe_content: function( iframe_id, content ) {
            var iframe = gEBI( iframe_id );
            iframe.contentWindow.document.open();
            iframe.contentWindow.document.write( content );
            iframe.contentWindow.document.close();
          }
        }

        // Code in global name space
        gEBI = function( id ) { return document.getElementById( id ) };

        window.onload = function() {
          // Next will not work with IE, but I don't care about IE.
          if( self==top ){ gEBI( 'demo_panels' ).style.height = ( Math.floor( window.innerHeight * 0.97) ).toString() + 'px' };
          // Browsers tend to return to last scroll position, we need to wait for
          // that to have happened or we still won't scroll back…
          window.setTimeout( function() { window.scrollTo( 0, 0 ) }, 100 );
          // Ensure transition panel can ben clicked away
          var hide_transition_container = function() {
            transition_container.style.display = "none";
          }
          function showTransitionSlide( code_to_highlight ) {
            var transition_container = gEBI( 'transition_container' );
            transition_container.style.display = "block";
            gEBI( 'working_code' ).innerHTML = code_to_highlight;
            Prism.highlightElement( gEBI( 'working_code' ) );
          }
          transition_container.addEventListener( 'click', hide_transition_container );
          // Load JSON source, visualize text from JSON
          var json = new JSON_MODULE();
          json.getExampleJSON( function( json_data ) {
            TextTransformers.set_textarea_content( 'json', JSON.stringify( json_data ) );
            var transformer = new TextTransformers.JsonToHtmlTransformer();
            TextTransformers.set_iframe_content( 'iframe_json', transformer.transform( json_data ) );
          } );
          // Event handler to transform JSON to TEI, load that into next 'slide',
          // visualize text from it, show transition 'slide' with transformative
          // code, move to TEI 'slide'
          gEBI( 'to_tei' ).addEventListener( 'click', function() {
            var left_x = gEBI( 'demo_panel_002' ).offsetLeft;
            scrollToX( left_x, 500, 'easeInOutQuint' );
            showTransitionSlide( TextTransformers.JsonToTeiTransformer );
            var transformer = new TextTransformers.JsonToTeiTransformer();
            gEBI( 'tei' ).value = transformer.transform( gEBI( 'json' ).value );
            transformer = new TextTransformers.TeiToHTMLTransformer();
            transformer.transform( gEBI( 'tei' ).value, function( tei_as_html ) {
              TextTransformers.set_iframe_content( 'iframe_tei', tei_as_html );
            } );
          } );
          // Event handler to transform TEI to .dot, load that into next 'slide',
          // visualize graph from it, show transition 'slide' with transformative
          // code, move to .dot 'slide'
          gEBI( 'to_dot' ).addEventListener( 'click', function() {
            var left_x = gEBI( 'demo_panel_003' ).offsetLeft;
            scrollToX( left_x, 500, 'easeInOutQuint' );
            showTransitionSlide( TextTransformers.TeiToDotTransformer );
            var transformer = new TextTransformers.TeiToDotTransformer();
            gEBI( 'dot' ).value = transformer.transform( gEBI( 'tei' ).value );
            // A total hack to keep the graph rendering from preventing the
            // transition slide to show…
            window.setTimeout( function() {
              var svg_renderer = new SVG_MODULE();
              svg_renderer.render_dot( gEBI( 'dot' ).value, '#svg_graph g' );
            }, 2000 );
          } );
          // Temporary: just here to prove we can go 'back'
          gEBI( 'back_to_tei' ).addEventListener( 'click', function() {
            var left_x = gEBI( 'demo_panel_002' ).offsetLeft;
            scrollToX( left_x, 500, 'easeInOutQuint' );
          } );
        };
    </script>
</head>
<body>
    <div id="demo_panels">
      <div id="demo_panel_001" class="demo_panel">
        <textarea id="json"></textarea>
        <iframe id="iframe_json"></iframe>
        <div id="to_tei" class="button">json to tei</div>
      </div>
      <div id="demo_panel_002" class="demo_panel">
        <textarea id="tei"></textarea>
        <iframe id="iframe_tei"></iframe>
        <div id="to_dot" class="button">tei to .dot</div>
      </div>
      <div id="demo_panel_003" class="demo_panel">
        <textarea id="dot"></textarea>
        <svg id="svg_graph"></svg>
        <div id="back_to_tei" class="button">back</div>
      </div>
    </div>

    <!-- Transition container, that which is shown during sliding/animating -->
    <div id="transition_container">
      <div id="transition_canvas">
        <pre><code class="language-javascript" id="working_code"></code></pre>
      </div>
    </div>

</body>
</html>
